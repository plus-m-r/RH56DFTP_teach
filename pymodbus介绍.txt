pymodbus 是一个功能全面的 Modbus 协议栈 Python 实现，
适用于需要可靠 Modbus 通信的场景，
支持 Python 3.8 及以上版本。

灵巧手使用Modbus TCP 控制时，通过IP 地址和端口号进行控制。
（默认IP 地址为192.168.11.210，端口号为6000）

pymodbus 是控制与理解如何控制灵巧手的一个良好的切入点。

控制，无非就是PC或者别的设备，发送信息给灵巧手，
灵巧手得到相应信息后做出相应反馈，并发送信息反馈给PC或者其他设备的过程，
pymodbus已经帮你处理好了绝大部分这种过程.

根据我上面的一段话你就可以得到两个主体,你的电脑和灵巧手，
电脑需要发送控制信息，灵巧手接收并反馈，当然电脑就需要接收到灵巧手的反馈。

这样就引出了pymodbus 的第一个组件，client（客户端）。

client 中，我们只关注灵巧手所使用的TCP协议，ModbusTcpClient，由于只有一个灵巧手，
异步 TCP 客户端就是不需要的，至少对于目前来说是这样。

客户端代表的就是您的电脑，有客户端就有服务端也就是灵巧手(pymodbus.sever),
这一款灵巧手我查过了他是自己配置了服务端不要你写.所以这个组件的话,接下来可能用的不多.

两个主体一条线，这条线中传输了什么信息，信息的格式是什么，电脑发送的信息，想要被灵巧手成功接收，
就必须采用相应的格式或者说数据结构，这个是约定好的。不然的话电脑讲中文，
灵巧手接受英文两个怎么能说得通呢？

这个数据结构就是Framer，pymodbus的组件之一，
Framer这个组件中有各种协议的格式,可以将特定的信息处理成对应协议可以接受的格式.

数据结构中的数据,指的就是PDU.
PDU 是在特定协议层中交换的数据单元，它包含了该层协议所需的所有控制信息和用户数据。

两者搭配就形成了一个所谓的数据包,客户端与服务端通过这个有明确格式的数据包就可以交流,
用快递来举例的话.PDU就是这个快递中的内容物，Framer就是一个箱子，
假设a公司他发圆通快递，b公司与他约定好也只接收圆通快递，但如果这时候a公司使用了韵达快递的话，
B公司就不能理解他为什么发韵达快递从而拒收，因为存在有可能是收到错误快递的风险。
当然a公司不可能只和B公司一家合作，他也需要发其他的快递，但有可能发的东西都是一样的，
只是需要经过不同的包装，这就是为什么PDU和Framer它是一个分离式的设计。
如果对于每家公司我都要重新设计自己发出去的东西，工作量就太大了。

当然，实际上在高速公路上跑的就是Framer，这个很好理解，因为PDU已经装进去了。

说到高速公路，在电脑通信的世界，与其说是路不如说是传送带。不过特别的是不同的传送带都需要不同的运载的车子，
因为这些传送带都有各种奇奇怪怪的形状，传输的信息必须适配这些形状才能进行飞驰。
当然你不能指望箱子Framer来适配这些传送带的形状，不然的话同一个快递发在不同的路上还要进行重新包装吗？
这时候就得请出专门用来运这些箱子的车子Transport，也叫传输层。
它可以以处理各种路面，你所需要做的就是把箱子装上去。
这些处理完成之后剩下的就不用管了，如何解析这个Framer，这就是灵巧手的工作了。

灵巧手获得我们发送的PDU后，会根据PDU种类与内容，进行不同的反馈，
PDU 由功能码+数据组成。功能码为1 个字节，数据长度不定，由具体功能决定。
功能码即种类，数据即内容。

灵巧手只接受03、06 和16 三种功能码，
读寄存器-03（单个或多个），写单个寄存器-06，写多个寄存器-16，具体看说明书。
灵巧手会跟据寄存器的值改变自己的状态。

了解了这些后，你就可以丝滑的看并学习我写的对于RH56DFTP的demo代码了,我们使用Modbus TCP，
即网线。